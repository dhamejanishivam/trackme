<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYBER TRACK :: REAL DATA ONLY</title>
    <style>
        :root {
            --neon-pink: #ff2a6d;
            --neon-blue: #05d9e8;
            --neon-purple: #d300c5;
            --neon-green: #00ff9d;
            --neon-red: #ff0000;
            --dark-bg: #0d0221;
            --darker-bg: #050110;
            --text-color: #d1f7ff;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--text-color);
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            line-height: 1.6;
        }

        .glitch {
            position: relative;
        }

        .glitch::before,
        .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.8;
        }

        .glitch::before {
            color: var(--neon-blue);
            z-index: -1;
            animation: glitch-effect 3s infinite;
        }

        .glitch::after {
            color: var(--neon-pink);
            z-index: -2;
            animation: glitch-effect 2s infinite reverse;
        }

        @keyframes glitch-effect {
            0% {
                transform: translate(0);
            }

            20% {
                transform: translate(-3px, 3px);
            }

            40% {
                transform: translate(-3px, -3px);
            }

            60% {
                transform: translate(3px, 3px);
            }

            80% {
                transform: translate(3px, -3px);
            }

            100% {
                transform: translate(0);
            }
        }

        .terminal {
            background-color: var(--darker-bg);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 15px var(--neon-blue),
                0 0 30px var(--neon-purple);
            border-radius: 5px;
            padding: 20px;
            margin: 20px auto;
            max-width: 900px;
            position: relative;
            overflow: hidden;
        }

        .terminal::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 15px;
            background: linear-gradient(90deg,
                    var(--neon-pink),
                    var(--neon-blue),
                    var(--neon-purple));
            opacity: 0.3;
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(5, 217, 232, 0.1) 1px,
                    transparent 1px);
            background-size: 100% 2px;
            pointer-events: none;
            animation: scanline 8s linear infinite;
        }

        @keyframes scanline {
            from {
                transform: translateY(0);
            }

            to {
                transform: translateY(100%);
            }
        }

        h1,
        h2,
        h3 {
            color: var(--neon-pink);
            text-shadow: 0 0 5px var(--neon-pink);
        }

        a {
            color: var(--neon-blue);
            text-decoration: none;
            transition: text-shadow 0.3s;
        }

        a:hover {
            text-shadow: 0 0 10px var(--neon-blue);
        }

        .neon-text {
            text-shadow: 0 0 5px currentColor;
        }

        .pink {
            color: var(--neon-pink);
        }

        .blue {
            color: var(--neon-blue);
        }

        .purple {
            color: var(--neon-purple);
        }

        .green {
            color: var(--neon-green);
        }

        .red {
            color: var(--neon-red);
        }

        .blink {
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        .matrix-rain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.1;
            pointer-events: none;
        }

        .consent-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(5, 1, 16, 0.9);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .consent-box {
            background-color: var(--darker-bg);
            border: 2px solid var(--neon-red);
            box-shadow: 0 0 20px var(--neon-red),
                0 0 40px var(--neon-pink);
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .consent-box h2 {
            margin-top: 0;
        }

        .consent-options {
            margin: 20px 0;
        }

        .consent-btn {
            background: none;
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 10px;
        }

        .consent-btn:hover {
            background-color: var(--neon-blue);
            color: var(--dark-bg);
            box-shadow: 0 0 10px var(--neon-blue);
        }

        .consent-btn.danger {
            border-color: var(--neon-red);
            color: var(--neon-red);
        }

        .consent-btn.danger:hover {
            background-color: var(--neon-red);
            color: var(--dark-bg);
            box-shadow: 0 0 10px var(--neon-red);
        }

        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .data-card {
            background-color: rgba(5, 217, 232, 0.05);
            border: 1px solid var(--neon-blue);
            padding: 15px;
            border-radius: 5px;
            transition: all 0.3s;
        }

        .data-card:hover {
            background-color: rgba(5, 217, 232, 0.1);
            box-shadow: 0 0 10px var(--neon-blue);
        }

        .data-card h3 {
            margin-top: 0;
            border-bottom: 1px solid var(--neon-purple);
            padding-bottom: 5px;
        }

        .progress-container {
            width: 100%;
            background-color: rgba(255, 42, 109, 0.1);
            border-radius: 5px;
            margin: 10px 0;
        }

        .progress-bar {
            height: 10px;
            background: linear-gradient(90deg,
                    var(--neon-pink),
                    var(--neon-purple));
            border-radius: 5px;
            transition: width 0.5s;
        }

        .typing {
            border-right: 2px solid var(--neon-blue);
            animation: blink 1s step-end infinite;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .warning {
            color: var(--neon-red);
            animation: warning-pulse 1s infinite;
        }

        @keyframes warning-pulse {
            0% {
                text-shadow: 0 0 5px var(--neon-red);
            }

            50% {
                text-shadow: 0 0 20px var(--neon-red);
            }

            100% {
                text-shadow: 0 0 5px var(--neon-red);
            }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .data-grid {
                grid-template-columns: 1fr;
            }

            .terminal {
                margin: 10px;
                padding: 15px;
            }
        }
    </style>
</head>

<body>
    <canvas id="matrix" class="matrix-rain"></canvas>
    <div class="scanlines"></div>

    <!-- Consent Modal -->
    <div id="consentModal" class="consent-modal">
        <div class="consent-box">
            <h2 class="glitch" data-text="TRACK ME?">TRACK ME?</h2>
            <p>This is an <span class="neon-text red">extreme</span> awareness demonstration showing <span
                    class="neon-text pink">REAL DATA</span> websites can collect about you.</p>
            <p class="warning">WARNING: We will collect <span class="neon-text red">REAL DATA</span> about your device,
                behavior, and more. All data will be displayed to you in real-time and is NOT stored on our servers.</p>

            <div class="consent-options">
                <h3>We will track:</h3>
                <ul>
                    <li>Your <span class="neon-text pink">REAL IP & LOCATION</span> (via ip-api.com)</li>
                    <li><span class="neon-text blue">DEVICE FINGERPRINT</span> (hardware, software, battery)</li>
                    <li><span class="neon-text purple">NETWORK DETAILS</span> (IP, ISP, connection type)</li>
                    <li><span class="neon-text green">BROWSER STORAGE</span> (localStorage, sessionStorage)</li>
                    <li><span class="neon-text red">SOCIAL MEDIA COOKIES</span> (if present)</li>
                    <li><span class="neon-text pink">MOUSE & KEYSTROKE DYNAMICS</span> (typing patterns, mouse
                        movements)</li>
                    <li><span class="neon-text blue">MICROPHONE ACCESS</span> (if permitted)</li>
                    <li><span class="neon-text purple">CLIPBOARD DATA</span> (if you paste something)</li>
                </ul>

                <div>
                    <input type="checkbox" id="consentCheckbox">
                    <label for="consentCheckbox">I understand and consent to <span class="neon-text red">REAL DATA
                            COLLECTION</span> for demonstration purposes</label>
                </div>
            </div>

            <div>
                <button id="consentAccept" class="consent-btn" disabled>TRACK ME FOR REAL</button>
                <button id="consentDeny" class="consent-btn danger">REJECT (BUT REMEMBER: THEY STILL TRACK YOU)</button>
            </div>
        </div>
    </div>

    <div class="container">
        <header class="terminal" style="margin-top: 50px;">
            <h1 class="glitch" data-text="CYBER TRACK :: REAL DATA MODE">CYBER TRACK :: REAL DATA MODE</h1>
            <p>> <span class="typing" id="typingText"></span><span class="blink">_</span></p>
            <div class="progress-container">
                <div id="trackingProgress" class="progress-bar" style="width: 0%"></div>
            </div>
            <p id="trackingStatus">Initializing <span class="neon-text red">REAL TRACKING SYSTEMS</span>... 0%</p>
        </header>

        <main>
            <section class="terminal">
                <h2>YOUR DIGITAL FINGERPRINT <span class="blink red">!</span></h2>
                <div class="data-grid" id="fingerprintData">
                    <!-- Filled by JavaScript -->
                </div>
            </section>

            <section class="terminal">
                <h2>BEHAVIORAL SURVEILLANCE <span class="blink pink">!</span></h2>
                <div class="data-grid" id="behavioralData">
                    <!-- Filled by JavaScript -->
                </div>
            </section>

            <section class="terminal">
                <h2>NETWORK INTRUSION <span class="pulse blue">!</span></h2>
                <div class="data-grid" id="networkData">
                    <!-- Filled by JavaScript -->
                </div>
            </section>

            <section class="terminal">
                <h2>REAL-TIME STALKING <span class="warning">!</span></h2>
                <div id="realtimeData">
                    <div class="data-card">
                        <h3>EYE TRACKING (ESTIMATED)</h3>
                        <div id="eyeTracking"
                            style="height: 200px; background-color: var(--darker-bg); border: 1px solid var(--neon-purple); position: relative;">
                            <div id="eyePosition"
                                style="position: absolute; width: 20px; height: 20px; background-color: var(--neon-pink); border-radius: 50%; transform: translate(-10px, -10px);">
                            </div>
                        </div>
                    </div>

                    <div class="data-card">
                        <h3>MOUSE MOVEMENT HEATMAP</h3>
                        <canvas id="heatmap"
                            style="width: 100%; height: 200px; background-color: var(--darker-bg); border: 1px solid var(--neon-blue);"></canvas>
                    </div>

                    <div class="data-card">
                        <h3>KEYSTROKE DYNAMICS</h3>
                        <p>Average time between keystrokes: <span id="avgKeystrokeTime">0</span>ms</p>
                        <p>Typing speed: <span id="typingSpeed">0</span> CPM</p>
                        <p>Typing rhythm pattern: <span id="typingPattern">Not detected</span></p>
                    </div>
                </div>
            </section>

            <section class="terminal">
                <h2>BROWSER STORAGE SCAN <span class="blink green">!</span></h2>
                <div class="data-grid" id="storageData">
                    <!-- Filled by JavaScript -->
                </div>
            </section>

            <section class="terminal">
                <h2>PRIVACY SCORE <span class="blink warning">!</span></h2>
                <div class="progress-container">
                    <div id="privacyScoreBar" class="progress-bar"
                        style="width: 100%; background: linear-gradient(90deg, var(--neon-pink), var(--neon-blue));">
                    </div>
                </div>
                <p id="privacyScoreText">Calculating your privacy score... <span class="blink">_</span></p>
                <p id="privacyRecommendations">Recommendations will appear here</p>
            </section>
        </main>

        <footer class="terminal" style="text-align: center; margin-bottom: 50px;">
            <p class="neon-text purple">THIS IS A <span class="neon-text red">REAL DATA</span> AWARENESS DEMONSTRATION
            </p>
            <p>All data collected is shown only to you and is not stored on any server.</p>
            <p>The purpose is to show <span class="neon-text pink">HOW MUCH DATA IS LEAKED EVERY DAY</span> without your
                knowledge.</p>
            <p class="warning">Now imagine this data being collected <span class="neon-text red">SILENTLY</span> by
                countless websites every day.</p>
        </footer>
    </div>

    <script>
        // Matrix rain effect
        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const katakana = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッン';
        const latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const nums = '0123456789';
        const symbols = '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~';

        const alphabet = katakana + latin + nums + symbols;

        const fontSize = 16;
        const columns = canvas.width / fontSize;

        const rainDrops = [];

        for (let x = 0; x < columns; x++) {
            rainDrops[x] = 1;
        }

        const draw = () => {
            ctx.fillStyle = 'rgba(5, 2, 33, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#0ff';
            ctx.font = fontSize + 'px monospace';

            for (let i = 0; i < rainDrops.length; i++) {
                const text = alphabet.charAt(Math.floor(Math.random() * alphabet.length));
                ctx.fillText(text, i * fontSize, rainDrops[i] * fontSize);

                if (rainDrops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    rainDrops[i] = 0;
                }
                rainDrops[i]++;
            }
        };

        setInterval(draw, 30);

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Consent handling
        const consentModal = document.getElementById('consentModal');
        const consentCheckbox = document.getElementById('consentCheckbox');
        const consentAccept = document.getElementById('consentAccept');
        const consentDeny = document.getElementById('consentDeny');

        consentCheckbox.addEventListener('change', () => {
            consentAccept.disabled = !consentCheckbox.checked;
        });

        consentAccept.addEventListener('click', () => {
            consentModal.style.display = 'none';
            startTracking();
        });

        consentDeny.addEventListener('click', () => {
            document.body.innerHTML = `
                <div style="display: flex; justify-content: center; align-items: center; height: 100vh; background-color: var(--dark-bg); color: var(--neon-red); font-family: monospace; text-align: center;">
                    <div>
                        <h1 style="font-size: 3em; margin-bottom: 20px;">TRACKING REJECTED</h1>
                        <p style="font-size: 1.5em;">You chose privacy. Good for you.</p>
                        <p style="font-size: 1.2em;">But remember: <span class="neon-text pink">most websites don't ask for consent.</span></p>
                        <p style="font-size: 1em; margin-top: 50px;"><a href="#" onclick="location.reload()" style="color: var(--neon-blue);">Change your mind?</a></p>
                    </div>
                </div>
            `;
        });

        // Typing effect
        const typingText = document.getElementById('typingText');
        const messages = [
            "Initializing deep tracking protocols...",
            "Bypassing privacy safeguards...",
            "Activating behavioral analysis...",
            "Preparing data extraction...",
            "Establishing neural connection...",
            "Mapping digital fingerprint..."
        ];

        let currentMessage = 0;
        let charIndex = 0;
        let isDeleting = false;
        let typingTimeout;

        const type = () => {
            const fullText = messages[currentMessage];

            if (isDeleting) {
                typingText.textContent = fullText.substring(0, charIndex - 1);
                charIndex--;
            } else {
                typingText.textContent = fullText.substring(0, charIndex + 1);
                charIndex++;
            }

            if (!isDeleting && charIndex === fullText.length) {
                isDeleting = true;
                typingTimeout = setTimeout(type, 1000);
            } else if (isDeleting && charIndex === 0) {
                isDeleting = false;
                currentMessage = (currentMessage + 1) % messages.length;
                typingTimeout = setTimeout(type, 500);
            } else {
                const speed = isDeleting ? 50 : 100;
                typingTimeout = setTimeout(type, speed);
            }
        };

        // Start tracking function
        const startTracking = () => {
            type();

            // Simulate progress
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += Math.random() * 5;
                if (progress > 100) progress = 100;

                document.getElementById('trackingProgress').style.width = `${progress}%`;
                document.getElementById('trackingStatus').textContent =
                    `Tracking systems ${progress === 100 ? 'fully' : 'partially'} operational... ${Math.floor(progress)}%`;

                if (progress === 100) {
                    clearInterval(progressInterval);
                    document.getElementById('trackingStatus').innerHTML =
                        '<span class="neon-text red">TRACKING SYSTEMS FULLY ENGAGED</span>';
                }
            }, 200);

            // Collect and display all possible data
            setTimeout(() => {
                collectFingerprintData();
                collectBehavioralData();
                collectNetworkData();
                collectStorageData();
                startRealtimeTracking();
                calculatePrivacyScore();
            }, 1500);
        };

        // Fingerprint data collection
        const collectFingerprintData = () => {
            const fingerprintData = document.getElementById('fingerprintData');

            // Browser info
            const browserData = {
                'User Agent': navigator.userAgent,
                'Browser Language': navigator.language,
                'Cookies Enabled': navigator.cookieEnabled ? 'Yes' : 'No',
                'Do Not Track': navigator.doNotTrack || 'Not specified',
                'WebDriver': navigator.webdriver ? 'Detected' : 'Not detected',
                'PDF Viewer': navigator.pdfViewerEnabled ? 'Enabled' : 'Disabled',
                'Hardware Concurrency': navigator.hardwareConcurrency || 'Unknown',
                'Device Memory': navigator.deviceMemory ? `${navigator.deviceMemory}GB` : 'Unknown',
                'Max Touch Points': navigator.maxTouchPoints || 'None'
            };

            // Screen info
            const screenData = {
                'Screen Resolution': `${window.screen.width} × ${window.screen.height}`,
                'Color Depth': `${window.screen.colorDepth} bits`,
                'Pixel Ratio': window.devicePixelRatio || 1,
                'Orientation': window.screen.orientation ? window.screen.orientation.type : 'Unknown',
                'Available Screen': `${window.screen.availWidth} × ${window.screen.availHeight}`
            };

            // GPU info
            const gpuData = {};
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

            if (gl) {
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    gpuData['GPU Vendor'] = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                    gpuData['GPU Renderer'] = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                }

                gpuData['WebGL Vendor'] = gl.getParameter(gl.VENDOR);
                gpuData['WebGL Renderer'] = gl.getParameter(gl.RENDERER);
            }

            // Audio context fingerprint
            const audioContextData = {};
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const analyser = audioContext.createAnalyser();
                const gainNode = audioContext.createGain();
                const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);

                oscillator.type = 'triangle';
                oscillator.connect(analyser);
                analyser.connect(scriptProcessor);
                scriptProcessor.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.start(0);

                const audioFingerprint = [];
                scriptProcessor.onaudioprocess = function (e) {
                    const output = e.outputBuffer.getChannelData(0);
                    for (let i = 0; i < output.length; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                    audioFingerprint.push(output);
                };

                setTimeout(() => {
                    oscillator.stop();
                    audioContext.close();
                    audioContextData['Audio Fingerprint'] = 'Detected (hash: ' + hashCode(JSON.stringify(audioFingerprint.slice(0, 10))) + ')';
                    updateDataCard('fingerprintData', 'AUDIO FINGERPRINT', audioContextData);
                }, 100);
            } catch (e) {
                audioContextData['Audio Fingerprint'] = 'Failed to detect';
            }

            // Canvas fingerprint
            const canvasData = {};
            try {
                canvas.width = 200;
                canvas.height = 50;
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.textBaseline = 'alphabetic';
                ctx.fillStyle = '#f60';
                ctx.fillRect(0, 0, 100, 50);
                ctx.fillStyle = '#069';
                ctx.fillText('Canvas Fingerprint', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('Canvas Fingerprint', 4, 17);

                canvasData['Canvas Fingerprint'] = 'Detected (hash: ' + hashCode(canvas.toDataURL()) + ')';
            } catch (e) {
                canvasData['Canvas Fingerprint'] = 'Failed to detect';
            }

            // Create data cards
            updateDataCard('fingerprintData', 'BROWSER DATA', browserData);
            updateDataCard('fingerprintData', 'SCREEN DATA', screenData);
            if (Object.keys(gpuData).length > 0) {
                updateDataCard('fingerprintData', 'GPU DATA', gpuData);
            }
            updateDataCard('fingerprintData', 'CANVAS FINGERPRINT', canvasData);
        };

        // Behavioral data collection
        const collectBehavioralData = () => {
            const behavioralData = document.getElementById('behavioralData');

            // Timezone
            const timezoneData = {
                'Timezone': Intl.DateTimeFormat().resolvedOptions().timeZone,
                'Timezone Offset': new Date().getTimezoneOffset(),
                'Locale': navigator.language,
                'Date Format': new Date().toLocaleDateString(),
                'Time Format': new Date().toLocaleTimeString()
            };

            // Fonts
            const fontData = {};
            const testText = "mmMwWLliI0O&1";
            const testSize = '30px';
            const fonts = [
                'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',
                'Georgia', 'Impact', 'Times New Roman', 'Trebuchet MS',
                'Verdana', 'Webdings', 'Wingdings', 'MS Sans Serif',
                'MS Serif', 'Lucida Console', 'Lucida Sans Unicode',
                'Palatino Linotype', 'Tahoma', 'Geneva'
            ];

            const availableFonts = [];
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            fonts.forEach(font => {
                context.font = testSize + ' ' + font;
                const metrics1 = context.measureText(testText);
                context.font = testSize + ' sans-serif';
                const metrics2 = context.measureText(testText);

                if (metrics1.width !== metrics2.width) {
                    availableFonts.push(font);
                }
            });

            fontData['Available Fonts'] = availableFonts.join(', ') || 'Unknown';

            // Plugins
            const pluginData = {};
            const plugins = Array.from(navigator.plugins || []).map(p => p.name);
            pluginData['Installed Plugins'] = plugins.length > 0 ? plugins.join(', ') : 'None detected';

            // Create data cards
            updateDataCard('behavioralData', 'TIMEZONE DATA', timezoneData);
            updateDataCard('behavioralData', 'FONT DATA', fontData);
            updateDataCard('behavioralData', 'PLUGIN DATA', pluginData);
        };

        // Network data collection
        const collectNetworkData = () => {
            const networkData = document.getElementById('networkData');

            // Connection info
            const connectionData = {};
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;

            if (connection) {
                connectionData['Connection Type'] = connection.type || 'Unknown';
                connectionData['Effective Type'] = connection.effectiveType || 'Unknown';
                connectionData['Downlink'] = connection.downlink ? `${connection.downlink} Mbps` : 'Unknown';
                connectionData['RTT'] = connection.rtt ? `${connection.rtt} ms` : 'Unknown';
                connectionData['Save Data'] = connection.saveData ? 'Enabled' : 'Disabled';
            } else {
                connectionData['Connection Info'] = 'Not available';
            }

            // Get real IP and location
            fetch('https://ipapi.co/json/')
                .then(response => response.json())
                .then(data => {
                    const ipData = {
                        'Public IP': data.ip || 'Unknown',
                        'Country': data.country_name || 'Unknown',
                        'Region': data.region || 'Unknown',
                        'City': data.city || 'Unknown',
                        'ISP': data.org || 'Unknown',
                        'VPN/Proxy': data.vpn || data.proxy ? 'Likely' : 'Unlikely'
                    };
                    updateDataCard('networkData', 'IP & LOCATION', ipData);
                })
                .catch(() => {
                    const ipData = {
                        'Public IP': 'Blocked by browser',
                        'Location': 'Unknown'
                    };
                    updateDataCard('networkData', 'IP & LOCATION', ipData);
                });

            // Battery status
            if ('getBattery' in navigator) {
                navigator.getBattery().then(battery => {
                    const batteryData = {
                        'Battery Level': `${Math.floor(battery.level * 100)}%`,
                        'Charging': battery.charging ? 'Yes' : 'No',
                        'Time to Charge': battery.charging ?
                            (battery.chargingTime === Infinity ? 'Unknown' : `${Math.floor(battery.chargingTime / 60)} minutes`) :
                            (battery.dischargingTime === Infinity ? 'Unknown' : `${Math.floor(battery.dischargingTime / 60)} minutes`)
                    };
                    updateDataCard('networkData', 'BATTERY DATA', batteryData);
                });
            }
        };

        // Storage data collection
        const collectStorageData = () => {
            const storageData = document.getElementById('storageData');

            // localStorage scan
            const localStorageData = {};
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                localStorageData[key] = localStorage.getItem(key).substring(0, 50) + '...';
            }

            if (Object.keys(localStorageData).length > 0) {
                updateDataCard('storageData', 'LOCALSTORAGE DATA', localStorageData);
            } else {
                updateDataCard('storageData', 'LOCALSTORAGE DATA', { 'Status': 'Empty or blocked' });
            }

            // sessionStorage scan
            const sessionStorageData = {};
            for (let i = 0; i < sessionStorage.length; i++) {
                const key = sessionStorage.key(i);
                sessionStorageData[key] = sessionStorage.getItem(key).substring(0, 50) + '...';
            }

            if (Object.keys(sessionStorageData).length > 0) {
                updateDataCard('storageData', 'SESSIONSTORAGE DATA', sessionStorageData);
            } else {
                updateDataCard('storageData', 'SESSIONSTORAGE DATA', { 'Status': 'Empty or blocked' });
            }

            // Check for social media cookies
            const socialMediaData = {};
            if (document.cookie.includes('facebook')) socialMediaData['Facebook'] = 'Cookie detected';
            if (document.cookie.includes('google')) socialMediaData['Google'] = 'Cookie detected';
            if (document.cookie.includes('twitter')) socialMediaData['Twitter'] = 'Cookie detected';

            if (Object.keys(socialMediaData).length > 0) {
                updateDataCard('storageData', 'SOCIAL MEDIA COOKIES', socialMediaData);
            } else {
                updateDataCard('storageData', 'SOCIAL MEDIA COOKIES', { 'Status': 'No major trackers detected' });
            }
        };

        // Realtime tracking
        const startRealtimeTracking = () => {
            // Mouse movement tracking
            const eyeTracking = document.getElementById('eyeTracking');
            const eyePosition = document.getElementById('eyePosition');

            // Heatmap
            const heatmapCanvas = document.getElementById('heatmap');
            const heatmapCtx = heatmapCanvas.getContext('2d');
            heatmapCanvas.width = heatmapCanvas.offsetWidth;
            heatmapCanvas.height = heatmapCanvas.offsetHeight;

            // Initialize heatmap data
            const heatmapData = [];
            for (let i = 0; i < heatmapCanvas.width; i += 10) {
                for (let j = 0; j < heatmapCanvas.height; j += 10) {
                    heatmapData.push({ x: i, y: j, value: 0 });
                }
            }

            // Keystroke dynamics
            let lastKeyTime = 0;
            let keystrokeTimes = [];
            let keyCount = 0;
            let lastKeyCountUpdate = Date.now();

            // Track mouse movements
            document.addEventListener('mousemove', (e) => {
                // Eye tracking simulation
                const rect = eyeTracking.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                eyePosition.style.left = `${x}px`;
                eyePosition.style.top = `${y}px`;

                // Heatmap
                const heatX = e.clientX - heatmapCanvas.getBoundingClientRect().left;
                const heatY = e.clientY - heatmapCanvas.getBoundingClientRect().top;

                // Find nearest point in heatmap data
                let nearestIndex = 0;
                let minDist = Infinity;

                heatmapData.forEach((point, index) => {
                    const dist = Math.sqrt(Math.pow(point.x - heatX, 2) + Math.pow(point.y - heatY, 2));
                    if (dist < minDist) {
                        minDist = dist;
                        nearestIndex = index;
                    }
                });

                heatmapData[nearestIndex].value = Math.min(heatmapData[nearestIndex].value + 10, 100);

                // Draw heatmap
                heatmapCtx.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
                heatmapData.forEach(point => {
                    if (point.value > 0) {
                        const alpha = point.value / 100;
                        heatmapCtx.fillStyle = `rgba(255, 42, 109, ${alpha})`;
                        heatmapCtx.fillRect(point.x - 5, point.y - 5, 10, 10);
                    }
                });
            });

            // Track keystrokes
            document.addEventListener('keydown', (e) => {
                const now = Date.now();
                const timeBetweenKeys = now - lastKeyTime;

                if (lastKeyTime > 0 && timeBetweenKeys < 1000) {
                    keystrokeTimes.push(timeBetweenKeys);

                    // Update average
                    const avg = keystrokeTimes.reduce((a, b) => a + b, 0) / keystrokeTimes.length;
                    document.getElementById('avgKeystrokeTime').textContent = Math.floor(avg);
                }

                lastKeyTime = now;
                keyCount++;

                // Update typing speed (characters per minute)
                if (now - lastKeyCountUpdate > 1000) {
                    const cpm = keyCount * 60;
                    document.getElementById('typingSpeed').textContent = cpm;
                    keyCount = 0;
                    lastKeyCountUpdate = now;

                    // Detect typing pattern
                    if (keystrokeTimes.length > 10) {
                        const variance = calculateVariance(keystrokeTimes);
                        if (variance < 100) {
                            document.getElementById('typingPattern').textContent = 'Consistent (likely human)';
                        } else {
                            document.getElementById('typingPattern').textContent = 'Inconsistent (possible bot)';
                        }
                    }
                }
            });

            // Track clipboard
            document.addEventListener('paste', (e) => {
                const clipboardData = e.clipboardData || window.clipboardData;
                const pastedText = clipboardData.getData('text');

                const clipboardCard = document.createElement('div');
                clipboardCard.className = 'data-card';
                clipboardCard.innerHTML = `
                    <h3>CLIPBOARD DATA</h3>
                    <p>Pasted content: <span class="neon-text pink">${pastedText.substring(0, 100)}</span></p>
                    <p>Length: ${pastedText.length} characters</p>
                `;
                document.getElementById('realtimeData').appendChild(clipboardCard);
            });

            // Request microphone and camera access
            const requestMedia = () => {
                navigator.mediaDevices.getUserMedia({ audio: true, video: true })
                    .then(stream => {
                        const mediaCard = document.createElement('div');
                        mediaCard.className = 'data-card';
                        mediaCard.innerHTML = `
                            <h3>MICROPHONE & CAMERA ACCESS</h3>
                            <p class="neon-text red">GRANTED - LIVE FEED ACTIVE</p>
                            <video id="liveFeed" autoplay muted style="width: 100%; border: 1px solid var(--neon-red);"></video>
                            <audio id="audioFeed" autoplay style="display: none;"></audio>
                        `;
                        document.getElementById('realtimeData').appendChild(mediaCard);

                        const video = document.getElementById('liveFeed');
                        const audio = document.getElementById('audioFeed');
                        video.srcObject = stream;
                        audio.srcObject = stream;
                    })
                    .catch(err => {
                        const mediaCard = document.createElement('div');
                        mediaCard.className = 'data-card';
                        mediaCard.innerHTML = `
                            <h3>MICROPHONE & CAMERA ACCESS</h3>
                            <p>Status: <span class="neon-text blue">${err.message}</span></p>
                        `;
                        document.getElementById('realtimeData').appendChild(mediaCard);
                    });
            };

            // Request device motion and orientation
            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', (e) => {
                    const motionCard = document.querySelector('#realtimeData .data-card:nth-child(4)') || document.createElement('div');
                    motionCard.className = 'data-card';
                    motionCard.innerHTML = `
                        <h3>DEVICE MOTION</h3>
                        <p>Acceleration: 
                            X: ${e.acceleration.x?.toFixed(2) || 'N/A'}, 
                            Y: ${e.acceleration.y?.toFixed(2) || 'N/A'}, 
                            Z: ${e.acceleration.z?.toFixed(2) || 'N/A'}
                        </p>
                        <p>Rotation: 
                            Alpha: ${e.rotationRate.alpha?.toFixed(2) || 'N/A'}, 
                            Beta: ${e.rotationRate.beta?.toFixed(2) || 'N/A'}, 
                            Gamma: ${e.rotationRate.gamma?.toFixed(2) || 'N/A'}
                        </p>
                    `;
                    if (!motionCard.parentNode) {
                        document.getElementById('realtimeData').appendChild(motionCard);
                    }
                });
            }

            // Request geolocation
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const geoCard = document.createElement('div');
                        geoCard.className = 'data-card';
                        geoCard.innerHTML = `
                            <h3>PRECISE GEOLOCATION</h3>
                            <p>Latitude: <span class="neon-text pink">${position.coords.latitude}</span></p>
                            <p>Longitude: <span class="neon-text pink">${position.coords.longitude}</span></p>
                            <p>Accuracy: ${position.coords.accuracy} meters</p>
                            <p>Altitude: ${position.coords.altitude || 'N/A'}</p>
                            <p>Heading: ${position.coords.heading || 'N/A'}</p>
                            <p>Speed: ${position.coords.speed || 'N/A'} m/s</p>
                        `;
                        document.getElementById('realtimeData').appendChild(geoCard);
                    },
                    (err) => {
                        const geoCard = document.createElement('div');
                        geoCard.className = 'data-card';
                        geoCard.innerHTML = `
                            <h3>PRECISE GEOLOCATION</h3>
                            <p>Status: <span class="neon-text blue">${err.message}</span></p>
                        `;
                        document.getElementById('realtimeData').appendChild(geoCard);
                    },
                    { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                );
            }
            fetch('https://ipapi.co/json/')
    .then(response => response.json())
    .then(data => {
        const ipData = {
            'Public IP': data.ip || 'Unknown',
            'Country': data.country_name || 'Unknown',
            'Region': data.region || 'Unknown',
            'City': data.city || 'Unknown',
            'ISP': data.org || 'Unknown',
            'VPN/Proxy': data.vpn || data.proxy ? 'Likely' : 'Unlikely'
        };
        updateDataCard('networkData', 'IP & LOCATION', ipData);
    })

            // Battery status changes
            if ('getBattery' in navigator) {
                navigator.getBattery().then(battery => {
                    battery.addEventListener('levelchange', () => {
                        const batteryCard = document.querySelector('#networkData .data-card:nth-child(3)');
                        if (batteryCard) {
                            batteryCard.innerHTML = `
                                <h3>BATTERY DATA</h3>
                                <p>Battery Level: <span class="neon-text pink">${Math.floor(battery.level * 100)}%</span></p>
                                <p>Charging: ${battery.charging ? 'Yes' : 'No'}</p>
                                <p>Time to ${battery.charging ? 'full charge' : 'discharge'}: 
                                    ${battery.charging ?
                                    (battery.chargingTime === Infinity ? 'Unknown' : `${Math.floor(battery.chargingTime / 60)} minutes`) :
                                    (battery.dischargingTime === Infinity ? 'Unknown' : `${Math.floor(battery.dischargingTime / 60)} minutes`)}
                                </p>
                            `;
                        }
                    });
                });
            }

            // Request media after a delay to not overwhelm the user
            setTimeout(requestMedia, 3000);
        };

        // Calculate privacy score
        const calculatePrivacyScore = () => {
            let score = 100;
            const recommendations = [];

            // Deduct points based on trackable data
            if (navigator.userAgent.includes('Chrome')) score -= 5;
            if (navigator.cookieEnabled) score -= 10;
            if (navigator.doNotTrack !== '1') score -= 15;
            if (localStorage.length > 0) score -= 5;
            if (sessionStorage.length > 0) score -= 5;
            if (document.cookie.length > 0) score -= 10;
            if (navigator.plugins.length > 0) score -= 5;
            if (navigator.hardwareConcurrency > 2) score -= 2;
            if (window.devicePixelRatio > 1) score -= 2;

            // Ensure score doesn't go below 0
            score = Math.max(0, score);

            // Generate recommendations
            if (navigator.cookieEnabled) {
                recommendations.push('Disable cookies for better privacy');
            }
            if (navigator.doNotTrack !== '1') {
                recommendations.push('Enable Do Not Track in your browser settings');
            }
            if (localStorage.length > 0 || sessionStorage.length > 0) {
                recommendations.push('Clear browser storage regularly');
            }
            if (document.cookie.length > 0) {
                recommendations.push('Use cookie-blocking extensions');
            }
            if (recommendations.length === 0) {
                recommendations.push('You have good basic privacy practices! Consider using a privacy-focused browser for even more protection.');
            }

            // Update UI
            document.getElementById('privacyScoreBar').style.width = `${score}%`;
            document.getElementById('privacyScoreText').innerHTML = `
                Your privacy score: <span class="neon-text ${score > 70 ? 'green' : score > 30 ? 'blue' : 'red'}">${score}/100</span>
            `;
            document.getElementById('privacyRecommendations').innerHTML = `
                <strong>Recommendations:</strong><br>${recommendations.join('<br>')}
            `;
        };

        // Helper functions
        const updateDataCard = (containerId, title, data) => {
            const container = document.getElementById(containerId);
            const card = document.createElement('div');
            card.className = 'data-card';

            let html = `<h3>${title}</h3>`;
            for (const [key, value] of Object.entries(data)) {
                html += `<p><strong>${key}:</strong> <span class="neon-text blue">${value}</span></p>`;
            }

            card.innerHTML = html;
            container.appendChild(card);
        };

        const hashCode = (str) => {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0; // Convert to 32bit integer
            }
            return hash;
        };

        const calculateVariance = (array) => {
            const mean = array.reduce((a, b) => a + b) / array.length;
            return array.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / array.length;
        };

        // Start the demo with a delay to show the consent modal
        setTimeout(() => {
            consentModal.style.display = 'flex';
        }, 1000);
    </script>
</body>

</html>
